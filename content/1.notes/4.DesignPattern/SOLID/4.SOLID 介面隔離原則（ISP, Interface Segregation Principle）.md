---
date: 2023-04-15 22:52:46
title: SOLID 介面隔離原則
description: SOLID 介面隔離原則（ISP, Interface Segregation Principle Substitution Principle）
categories: [Design Pattern]
---

「介面隔離原則」（Interface Segregation Principle，簡稱 ISP）是 SOLID 設計原則的其中一項，指出一個類別不應該強迫實作它用不到的方法，也就是介面應該要小而專精，而不是大而全面。這樣可以讓系統更加靈活，並且可以讓介面更容易被維護。

### 生活中的例子

假設你有一個盒子，裡面裝了很多玩具，你想要找出某一種類的玩具，比如說是球類玩具，但是盒子裡有很多種類的玩具，你該怎麼做呢？

你可以先把所有的玩具拿出來，然後把球類玩具都放在一起，其他種類的玩具也放在自己的地方，這樣就可以快速找到想要的玩具了。這就是介面隔離原則的應用，讓不同種類的物品有自己的分類方式，便於查找和使用。

### JavaScript 範例

#### 錯誤範例

在這個範例中，在 Animal 中時做了 walk, swim, fly 方法，但並不是所有動物都會走路、游泳、飛行，反而還要在子類中複寫掉這些方法，因此並不符合介面隔離原則，一個類別不應該強迫實作它用不到的方法。

```js
class Animal {
  walk() {
    console.log('我會走路')
  }

  swim() {
    console.log('我會游泳')
  }

  fly() {
    console.log('我會飛')
  }
}

class Duck extends Animal {
  quack() {
    console.log('我會嘎嘎叫')
  }
}

class Penguin extends Animal {
  fly() {
    console.log('我不能飛') // 錯誤的實現，企鵝不能飛
  }
}

class Eagle extends Animal {
  swim() {
    console.log('我不能游泳') // 錯誤的實現，老鷹不能游泳
  }
}

const duck = new Duck()
duck.walk() // 我會走路
duck.swim() // 我會游泳
duck.quack() // 我會嘎嘎叫

const penguin = new Penguin()
penguin.walk() // 我會走路
penguin.swim() // 我會游泳
penguin.fly() // 我不能飛

const eagle = new Eagle()
eagle.walk() // 我會走路
eagle.fly() // 我會飛
eagle.swim() // 我不能游泳
```

#### 正確範例

使用「CanSwim」和「CanFly」介面，分別定義了游泳和飛行的行為，並最小化分離介面。而鴨子「Duck」繼承了「CanSwim」介面，企鵝「Penguin」也繼承了「CanSwim」介面，而老鷹「Eagle」則繼承了「CanFly」介面，這樣子類就不會需要實作它用不到的方法，符合「介面隔離原則」。

```js
class CanSwim {
  swim() {
    console.log('我會游泳')
  }
}

class CanFly {
  fly() {
    console.log('我會飛')
  }
}

class Duck extends CanSwim {
  quack() {
    console.log('我會嘎嘎叫')
  }
}

class Penguin extends CanSwim {
}

class Eagle extends CanFly {
}

const duck = new Duck()
duck.swim() // 我會游泳
duck.quack() // 我會嘎嘎叫

const penguin = new Penguin()
penguin.swim() // 我會游泳

const eagle = new Eagle()
eagle.fly() // 我會飛
```
